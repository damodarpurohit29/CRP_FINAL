import logging
from decimal import Decimal
from django.conf import settings
from django.contrib.contenttypes.fields import GenericForeignKey
from django.contrib.contenttypes.models import ContentType
from django.db import models
from django.db.models import Sum
from django.utils import timezone
from django.utils.translation import gettext_lazy as _
from django.core.exceptions import ValidationError as DjangoValidationError

# Assuming these are correctly defined elsewhere
from crp_core.enums import DrCrType, VoucherType, TransactionStatus, ApprovalActionType
from .coa import Account
from .party import Party
from .period import AccountingPeriod

logger = logging.getLogger(__name__)

# --- Sequence Configuration Model ---

class VoucherSequence(models.Model):
    """
    Stores configuration and the last used number for voucher sequences.
    Scope is defined by voucher_type and accounting_period.
    """
    voucher_type = models.CharField(
        max_length=20,
        choices=VoucherType.choices,
        help_text=_("The type of voucher this sequence is for.")
    )
    accounting_period = models.ForeignKey(
        AccountingPeriod,
        on_delete=models.CASCADE, # Sequence is tied to the period lifecycle
        help_text=_("The accounting period this sequence applies to.")
    )
    prefix = models.CharField(
        max_length=20, # e.g., "JV-2024Q1-"
        blank=True,
        help_text=_("Configurable prefix for the voucher number.")
    )
    padding_digits = models.PositiveSmallIntegerField(
        default=4,
        help_text=_("Number of digits for the sequential number (e.g., 4 -> 0001).")
    )
    last_number = models.PositiveIntegerField(
        default=0,
        help_text=_("The last sequential number used for this type/period.")
    )

    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        verbose_name = _("Voucher Sequence")
        verbose_name_plural = _("Voucher Sequences")
        unique_together = ('voucher_type', 'accounting_period') # Critical constraint
        ordering = ['accounting_period__start_date', 'voucher_type']

    def __str__(self):
        period_name = self.accounting_period if self.accounting_period else 'N/A'
        return f"{self.get_voucher_type_display()} sequence for {period_name}"

    def format_number(self, number: int) -> str:
        """Applies prefix and padding to format the final voucher number."""
        number_str = str(number).zfill(self.padding_digits)
        return f"{self.prefix}{number_str}"

# --- Core Voucher Models ---

class Voucher(models.Model):
    """
    Represents the header of a financial transaction (voucher/journal entry).
    Links together debit and credit lines that must balance.
    """
    date = models.DateField(
        default=timezone.now,
        db_index=True,
        help_text=_("Date the transaction occurred or is recorded")
    )
    effective_date = models.DateField(
        null=True, blank=True, db_index=True,
        help_text=_("Date for reporting/aging (e.g., Due Date). Defaults to transaction date if blank.")
    )
    # Generated by service, stored here. Blank initially.
    voucher_number = models.CharField(
        max_length=50,
        db_index=True,
        editable=False,
        blank=True,
        help_text=_("System-generated unique voucher number (e.g., JV-24Q1-0001)")
    )
    reference = models.CharField(
        max_length=100,
        blank=True, null=True,
        help_text=_("Optional external reference (e.g., invoice no, vendor bill no)")
    )
    narration = models.TextField(
        help_text=_("Overall description or reason for the transaction")
    )
    voucher_type = models.CharField(
        max_length=20,
        choices=VoucherType.choices,
        default=VoucherType.GENERAL,
        db_index=True,
        help_text=_("Classifies the entry type for reporting and workflow.")
    )
    status = models.CharField(
        max_length=20,
        choices=TransactionStatus.choices,
        default=TransactionStatus.DRAFT,
        db_index=True,
        help_text=_("Workflow status of the voucher")
    )
    party = models.ForeignKey(
        Party,
        on_delete=models.PROTECT, # Prevent deleting a Party with transactions
        null=True, blank=True, db_index=True,
        related_name="vouchers",
        help_text=_("Associated Party (Customer, Vendor), if applicable")
    )
    accounting_period = models.ForeignKey(
        AccountingPeriod,
        on_delete=models.PROTECT, # CRITICAL: Prevent deleting Period with transactions
        db_index=True,
        related_name="vouchers",
        help_text=_("The accounting period this voucher belongs to.")
    )

    # Generic FK for linking to source documents (Invoice, Bill, etc.)
    content_type = models.ForeignKey(
        ContentType,
        on_delete=models.SET_NULL,
        null=True, blank=True, db_index=True,
        related_name='vouchers'
    )
    object_id = models.PositiveIntegerField(
        null=True, blank=True, db_index=True
    )
    balances_updated = models.BooleanField(
        default=False,
        db_index=True,  # Index for faster checking in the task
        help_text=_("Internal flag: True if ledger balances have been updated by the posting task.")
    )
    source_document = GenericForeignKey('content_type', 'object_id')

    permissions = [
        ("submit_voucher", "Can submit voucher for approval"),
        ("approve_voucher", "Can approve voucher for posting"),
        ("reject_voucher", "Can reject voucher during approval"),
        ("reverse_voucher", "Can create reversing voucher entries"),
        ("post_voucher", "Can post vouchers directly (used by approve/reverse)"),  # Optional: If direct posting needed
        ("delete_draft_voucher", "Can delete draft/rejected vouchers"),  # Specific delete perm
    ]

    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        verbose_name = _("Voucher")
        verbose_name_plural = _("Vouchers")
        ordering = ['-date', '-voucher_number']
        indexes = [
            models.Index(fields=['content_type', 'object_id']),
            models.Index(fields=['status', 'accounting_period']),
        ]
        permissions = [
            ("submit_voucher", "Can submit voucher for approval"),
            ("approve_voucher", "Can approve voucher for posting"),
            ("reject_voucher", "Can reject voucher during approval"),
            ("reverse_voucher", "Can create reversing voucher entries"),
            ("post_voucher", "Can post vouchers directly"),
            ("delete_draft_voucher", "Can delete draft/rejected vouchers"),
        ]

    def __str__(self):
        return f"{self.voucher_number or f'Voucher #{self.pk}'} ({self.date})"

    # --- Properties for calculated values ---
    @property
    def total_debit(self) -> Decimal:
        """Calculates the sum of debit lines for this entry."""
        if hasattr(self, '_prefetched_objects_cache') and 'lines' in self._prefetched_objects_cache:
            return sum(line.amount for line in self._prefetched_objects_cache['lines'] if line.dr_cr == DrCrType.DEBIT)
        return self.lines.filter(dr_cr=DrCrType.DEBIT).aggregate(total=Sum('amount'))['total'] or Decimal('0.00')

    @property
    def total_credit(self) -> Decimal:
        """Calculates the sum of credit lines for this entry."""
        if hasattr(self, '_prefetched_objects_cache') and 'lines' in self._prefetched_objects_cache:
            return sum(line.amount for line in self._prefetched_objects_cache['lines'] if line.dr_cr == DrCrType.CREDIT)
        return self.lines.filter(dr_cr=DrCrType.CREDIT).aggregate(total=Sum('amount'))['total'] or Decimal('0.00')

    @property
    def is_balanced(self) -> bool:
        """Checks if total debits equal total credits and are non-zero."""
        debit = self.total_debit
        credit = self.total_credit
        return debit > 0 and debit.quantize(Decimal('0.01')) == credit.quantize(Decimal('0.01'))

    @property
    def is_editable(self) -> bool:
        """Determines if the voucher is in a state that allows modification."""
        return self.status not in [TransactionStatus.POSTED, TransactionStatus.CANCELLED]

    # --- Core Methods ---
    def clean(self):
        """Basic model-level validation."""
        super().clean()
        # Period Lock Check
        if self.accounting_period and self.accounting_period.locked:
            is_new = self._state.adding
            period_changed = False
            if not is_new:
                try:
                    original_period_id = Voucher.objects.values_list('accounting_period_id', flat=True).get(pk=self.pk)
                    if original_period_id != self.accounting_period_id:
                        period_changed = True
                except Voucher.DoesNotExist:
                    is_new = True
            if is_new or period_changed:
                raise DjangoValidationError(
                    {'accounting_period': _("Accounting period '%(name)s' is locked.") % {'name': self.accounting_period}}
                )
        # Effective Date Default
        if self.date and not self.effective_date:
            self.effective_date = self.date

    def save(self, *args, **kwargs):
        """Handles voucher saving, including triggering number generation."""
        is_new = self._state.adding
        original_status = None
        if not is_new:
            try: # Fetch efficiently if needed
                original_status = Voucher.objects.values_list('status', flat=True).get(pk=self.pk)
            except Voucher.DoesNotExist:
                is_new = True

        self.clean() # Run validations

        # --- Immutability Check ---
        if not is_new and original_status in [TransactionStatus.POSTED, TransactionStatus.CANCELLED]:
             # Allow specific status changes if needed (e.g., Posted -> Cancelled)
            if self.status != original_status and not (original_status == TransactionStatus.POSTED and self.status == TransactionStatus.CANCELLED):
                 raise DjangoValidationError(
                     _(f"Cannot change status from '{original_status}' to '{self.status}'. Voucher is locked.")
                 )
            # Add more checks here if other fields shouldn't change when Posted/Cancelled
            # For simplicity, allow save if only status changes as permitted above

        # --- Voucher Number Generation Trigger ---
        # Generate only if blank AND (it's new and not draft OR it's updating FROM draft)
        trigger_generation = False
        if not self.voucher_number:
            if is_new and self.status != TransactionStatus.DRAFT:
                trigger_generation = True
            elif not is_new and original_status == TransactionStatus.DRAFT and self.status != TransactionStatus.DRAFT:
                trigger_generation = True

        if trigger_generation:
            # Call the service function to handle generation and assignment
            from ..services.voucher_utils import assign_voucher_number # Local import
            try:
                assign_voucher_number(self) # Service assigns number to self.voucher_number
            except DjangoValidationError as e:
                # Re-raise the validation error from the service to halt save if needed
                logger.error(f"Voucher number generation failed for Voucher PK {self.pk}: {e}")
                raise e
        # --- End Generation Trigger ---

        super().save(*args, **kwargs) # Proceed with the actual save

class VoucherApproval(models.Model):
    """Tracks the workflow history (submit, approve, reject) of a Voucher."""
    voucher = models.ForeignKey(
        Voucher,
        related_name='approvals',
        on_delete=models.CASCADE, # Log lives and dies with the voucher
        help_text=_("The voucher this action relates to")
    )
    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.PROTECT, # Keep user reference even if user deleted?
        related_name='voucher_approval_actions',
        help_text=_("The user who performed the action")
    )
    action_timestamp = models.DateTimeField(
        default=timezone.now,
        help_text=_("When the action was performed")
    )
    action_type = models.CharField(
        max_length=20,
        choices=ApprovalActionType.choices,
        db_index=True,
        help_text=_("The type of workflow action taken")
    )
    from_status = models.CharField(
        max_length=20, choices=TransactionStatus.choices, null=True, blank=True,
        help_text=_("Status before this action")
    )
    to_status = models.CharField(
        max_length=20, choices=TransactionStatus.choices, null=True, blank=True,
        help_text=_("Status after this action (if changed)")
    )
    comments = models.TextField(
        blank=True,
        help_text=_("Optional comments provided by the user")
    )

    class Meta:
        verbose_name = _("Voucher Approval Log")
        verbose_name_plural = _("Voucher Approval Logs")
        ordering = ['action_timestamp'] # Chronological history
        indexes = [
             models.Index(fields=['voucher', 'action_timestamp']),
        ]

    def __str__(self):
        user_display = self.user.username if self.user else 'System'
        ts = self.action_timestamp.strftime('%Y-%m-%d %H:%M')
        return f"Voucher {self.voucher_id}: {self.get_action_type_display()} by {user_display} at {ts}"

class VoucherLine(models.Model):
    """Represents a single debit or credit line within a Voucher."""

    # Changed ForeignKey to point to Voucher
    voucher = models.ForeignKey(
        Voucher, # Changed from JournalEntry
        on_delete=models.CASCADE, # Lines belong exclusively to a voucher
        related_name='lines', # Kept the same related_name
        help_text=_("The voucher this line belongs to")
    )

    account = models.ForeignKey(
        Account,
        on_delete=models.PROTECT, # Keep PROTECT for accounts
        related_name='voucher_lines', # Changed related_name for consistency
        db_index=True, # Added index
        help_text=_("Account from the Chart of Accounts")
    )

    dr_cr = models.CharField(
        max_length=6,
        choices=DrCrType.choices, # Assumes DrCrType enum provides .choices
        help_text=_("Specifies if this is a debit or credit")
    )

    amount = models.DecimalField(
        max_digits=20,
        decimal_places=2, # Adjust as needed
        # Removed default=Decimal("0.00")
        help_text=_("Amount debited or credited (always positive)")
    )

    narration = models.TextField(
        blank=True,
        help_text=_("Optional description for this specific line")
    )

    created_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        # Using account_code if available, otherwise fallback
        acc_display = self.account.account_code if self.account and hasattr(self.account, 'account_code') else (self.account.account_name if self.account else 'N/A')
        return f"{self.dr_cr} {acc_display} - {self.amount}"

    def clean(self):
        """Validation for the line item."""
        super().clean()
        # Check amount is positive
        if self.amount is not None and self.amount <= 0:
            raise DjangoValidationError({'amount': _("Amount must be a positive number.")})
        # Check Dr/Cr is selected
        if not self.dr_cr:
             raise DjangoValidationError({'dr_cr': _("Debit/Credit type must be specified.")})
        # Check Account is selected (check the ID field)
        if not self.account_id:
             raise DjangoValidationError({'account': _("An account must be selected.")})

    def save(self, *args, **kwargs):
        """Prevent edits if the parent Voucher is immutable."""
        # This is a secondary check; Voucher.save() has the primary check.
        if self.voucher_id:
            try:
                # Fetch only status for efficiency
                parent_status = Voucher.objects.values_list('status', flat=True).get(pk=self.voucher_id)
                if parent_status in [TransactionStatus.POSTED, TransactionStatus.CANCELLED]:
                    is_new = self._state.adding
                    if is_new:
                         # Prevent adding new lines to posted/cancelled vouchers
                         raise DjangoValidationError(_(f"Cannot add lines to a voucher with status '{parent_status}'."))
                    else:
                         # Prevent modification of existing lines? More complex check needed here
                         # to see *if* anything actually changed if modification is disallowed.
                         # For now, just log a warning if save is attempted on line of immutable voucher.
                         logger.warning(f"Attempt to save VoucherLine {self.pk} for immutable Voucher {self.voucher_id} (Status: {parent_status})")
                         # If modification *must* be prevented, fetch original line and compare fields.
            except Voucher.DoesNotExist:
                logger.error(f"Attempted to save VoucherLine {self.pk} for non-existent Voucher {self.voucher_id}")
                # Consider raising an error here

        self.clean() # Run validation before saving
        super().save(*args, **kwargs)

    class Meta:
        # Updated names
        verbose_name = _("Voucher Line")
        verbose_name_plural = _("Voucher Lines")
        # Added ordering and indexes
        ordering = ['pk'] # Keep lines generally in creation order
        indexes = [
             models.Index(fields=['voucher', 'account']),
             models.Index(fields=['voucher', 'dr_cr']),
        ]
# from django.db import models
# from django.utils.translation import gettext_lazy as _
# from decimal import Decimal
#
# from crp_accounting.models.coa import Account
# from crp_accounting.models.party import Party
# from crp_accounting.models.period import AccountingPeriod
# from crp_core.enums import DrCrType, JournalType, TransactionStatus
#
# from rest_framework.exceptions import ValidationError
#
#
# class JournalEntry(models.Model):
#     """
#     Represents a single journal entry based on double-entry bookkeeping.
#     For every debit entry, there must be an equal credit entry to maintain the accounting equation.
#     """
#
#     date = models.DateField(auto_now_add=True, help_text=_("Date of the journal entry"))
#
#     reference = models.CharField(
#         max_length=100,
#         blank=True, null=True,
#         help_text=_("Optional reference number or code for the entry (e.g., invoice no, voucher no)")
#     )
#
#     narration = models.TextField(
#         blank=True,
#         help_text=_("Description or reason for the transaction")
#     )
#
#     journal_type = models.CharField(
#         max_length=20,
#         choices=[(jtype.name, jtype.value) for jtype in JournalType],
#         default=JournalType.GENERAL.name,
#         help_text=_("Type of journal entry, e.g., General, Payment, Receipt")
#     )
#
#     status = models.CharField(
#         max_length=20,
#         choices=[(status.name, status.value) for status in TransactionStatus],
#         default=TransactionStatus.PENDING.name,
#         help_text=_("Status of the journal entry (Pending, Posted, Cancelled)")
#     )
#
#     party = models.ForeignKey(
#         Party, on_delete=models.SET_NULL, null=True, blank=True,
#         related_name="journal_entries",
#         help_text=_("Party involved in this transaction, if any")
#     )
#
#     accounting_period = models.ForeignKey(
#         AccountingPeriod,
#         on_delete=models.CASCADE,
#         help_text=_("The accounting period for this journal entry.")
#     )
#
#     created_at = models.DateTimeField(auto_now_add=True)
#     updated_at = models.DateTimeField(auto_now=True)
#
#     def __str__(self):
#         return f"Journal Entry #{self.id} - {self.date} - {self.journal_type}"
#
#     def clean(self):
#         """
#         Custom validation to ensure:
#         - The journal entry can only be created in an open accounting period.
#         - The debit and credit amounts must balance.
#         """
#         # Check if the accounting period is locked
#         if self.accounting_period.locked:
#             raise ValidationError(_("This accounting period is locked. You cannot post entries in a locked period."))
#
#         # Check if the journal entries are balanced (debits = credits)
#         total_debit = sum(line.amount for line in self.lines.filter(dr_cr=DrCrType.DEBIT.name))
#         total_credit = sum(line.amount for line in self.lines.filter(dr_cr=DrCrType.CREDIT.name))
#
#         if total_debit != total_credit:
#             raise ValidationError(_("Debits and Credits do not balance."))
#
#     def save(self, *args, **kwargs):
#         """
#         Override save to perform validation and ensure journal entries are balanced.
#         """
#         self.clean()  # Perform the custom validation before saving
#         super(JournalEntry, self).save(*args, **kwargs)
#
#
# class JournalLine(models.Model):
#     """
#     Represents each line item in a journal entry.
#     A journal entry consists of at least two lines: one debit and one credit, both with equal amounts.
#     """
#
#     journal_entry = models.ForeignKey(
#         JournalEntry,
#         on_delete=models.CASCADE,
#         related_name='lines',
#         help_text=_("The journal entry this line belongs to")
#     )
#
#     account = models.ForeignKey(
#         Account,
#         on_delete=models.PROTECT,
#         related_name='journal_lines',
#         help_text=_("Account affected by this transaction line")
#     )
#
#     dr_cr = models.CharField(
#         max_length=6,
#         choices=[(t.name, t.value) for t in DrCrType],
#         help_text=_("Specifies if this is a debit or credit line")
#     )
#
#     amount = models.DecimalField(
#         max_digits=20,
#         decimal_places=2,
#         default=Decimal("0.00"),
#         help_text=_("Amount debited or credited")
#     )
#
#     narration = models.TextField(
#         blank=True,
#         help_text=_("Optional description for this line item")
#     )
#
#     created_at = models.DateTimeField(auto_now_add=True)
#
#     def __str__(self):
#         return f"{self.dr_cr} - {self.account.account_name} - {self.amount}"
#
#     def clean(self):
#         """
#         Optional: Enforce that amount must be positive and dr_cr must be valid.
#         """
#         if self.amount <= 0:
#             raise ValidationError(_("Amount must be greater than zero"))
#
#     class Meta:
#         verbose_name = _("Journal Line")
#         verbose_name_plural = _("Journal Lines")
