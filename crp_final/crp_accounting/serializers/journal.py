# crp_accounting/serializers.py

import logging
from decimal import Decimal
from rest_framework import serializers
from django.db import transaction
from django.utils.translation import gettext_lazy as _
from django.contrib.contenttypes.models import ContentType
# Note: DjangoValidationError is used when *catching* errors from model.clean/save
from django.core.exceptions import ValidationError as DjangoValidationError

# --- Model Imports ---
from ..models.journal import (
    Voucher, VoucherLine, Account, Party, AccountingPeriod,
    VoucherType, TransactionStatus, DrCrType # Make sure TransactionStatus is imported
)
# --- Enum/Constant Imports ---
# Assuming AccountType enum is defined/imported
# Import PartyType enum (Adjust path if Party model is elsewhere)
from crp_core.enums import PartyType # Make sure PartyType is imported
# Import constants (adjust path as needed)
from crp_core import constants # Assuming constants.py is in a 'core' app or similar

# --- Custom Exception Imports (Can be used for raising specific errors if needed) ---
# from .exceptions import InvalidVoucherStatusError, BalanceError, PeriodLockedError

logger = logging.getLogger(__name__)


# =============================================================================
# Dynamic Role Set Generation from Constants
# =============================================================================
# Helper function to extract role codes for specific categories
def get_roles_for_category(*category_names):
    """Extracts account role codes from constants.ACCOUNT_ROLE_GROUPS."""
    roles = set()
    for category in category_names:
        if category in constants.ACCOUNT_ROLE_GROUPS:
            # Assumes constants format is {'Category Name': [('role_code', 'Role Name'), ...]}
            roles.update(code for code, name in constants.ACCOUNT_ROLE_GROUPS[category])
    return roles

# Generate the sets dynamically (executed once when module is loaded)
# These provide efficient lookups for validation rules.
try:
    CASH_BANK_ROLES = get_roles_for_category('Assets - Current') & {'1000_cash', '1010_bank_accounts'}
    ACCOUNTS_RECEIVABLE_ROLES = get_roles_for_category('Assets - Current', 'Receivables') & {'1030_accounts_receivable', '9000_due_from_customers'}
    ACCOUNTS_PAYABLE_ROLES = get_roles_for_category('Liabilities - Current', 'Payables') & {'2000_accounts_payable', '9100_due_to_suppliers'}
    SALES_REVENUE_ROLES = get_roles_for_category('Income') & {'4010_service_revenue', '4020_sales_revenue'}
    # Add more sets as needed (e.g., EXPENSE_ROLES)
    logger.debug("Successfully generated Account Role Sets from constants.")
except AttributeError:
    logger.exception("Failed to generate Account Role Sets. Check core/constants.py structure.")
    # Define empty sets as fallback to prevent NameErrors later, but validation will likely fail
    CASH_BANK_ROLES = set()
    ACCOUNTS_RECEIVABLE_ROLES = set()
    ACCOUNTS_PAYABLE_ROLES = set()
    SALES_REVENUE_ROLES = set()

# =============================================================================
# Voucher Line Serializer
# =============================================================================
class VoucherLineSerializer(serializers.ModelSerializer):
    """
    Serializer for individual Voucher Line items.
    Handles validation and data transformation for API representation.
    """
    account = serializers.PrimaryKeyRelatedField(
        queryset=Account.objects.filter(is_active=True, allow_direct_posting=True), # Correct field name
        help_text=_("PK of the Account (must allow direct posting).")
    )
    # Read-only fields for display convenience
    account_code = serializers.CharField(source='account.account_code', read_only=True)
    account_name = serializers.CharField(source='account.account_name', read_only=True)

    class Meta:
        model = VoucherLine
        fields = [
            'id',           # Needed for updating existing lines
            'account',      # Writeable PK
            'account_code', # Read-only display
            'account_name', # Read-only display
            'dr_cr',
            'amount',
            'narration',
        ]
        # ID is generated by DB, not set by client
        read_only_fields = ['id']

    def validate_amount(self, value):
        """Ensure line amount is provided and positive."""
        if value is None:
            raise serializers.ValidationError(_("Amount cannot be null."))
        if value <= Decimal('0.00'):
            raise serializers.ValidationError(_("Amount must be a positive number."))
        return value

    def validate_dr_cr(self, value):
        """Ensure Debit/Credit type is provided."""
        if not value:
            raise serializers.ValidationError(_("Debit/Credit type (dr_cr) is required."))
        # Optional: could validate against DrCrType.choices here if needed
        return value

# =============================================================================
# Main Voucher Serializer
# =============================================================================
class VoucherSerializer(serializers.ModelSerializer):
    """
    Serializer for Voucher header and its nested lines.
    Handles creation and update operations, primarily for DRAFT vouchers.
    Validates data integrity, balance, date/period constraints, and type-specific rules.
    Workflow progression (submit, approve, etc.) is handled by dedicated service functions called from Views.
    """
    # --- Nested Lines ---
    # Requires at least two lines for a balanced entry.
    lines = VoucherLineSerializer(many=True, min_length=2)

    # --- Read-Only / Display Fields (Managed by system or calculated) ---
    voucher_number = serializers.CharField(read_only=True, help_text=_("System-generated voucher number (assigned on workflow progression)."))
    status = serializers.ChoiceField(choices=TransactionStatus.choices, read_only=True, help_text=_("Current workflow status (read-only via serializer)."))
    status_display = serializers.CharField(source='get_status_display', read_only=True, help_text=_("Display text for status."))
    total_debit = serializers.DecimalField(max_digits=20, decimal_places=2, read_only=True)
    total_credit = serializers.DecimalField(max_digits=20, decimal_places=2, read_only=True)
    is_balanced = serializers.BooleanField(read_only=True)
    is_editable = serializers.BooleanField(read_only=True)
    created_at = serializers.DateTimeField(read_only=True)
    updated_at = serializers.DateTimeField(read_only=True)
    # balances_updated is an internal flag, not exposed via API

    # --- Writeable Relations (Accept PKs on input) ---
    party = serializers.PrimaryKeyRelatedField(
        queryset=Party.objects.filter(is_active=True), # Only allow selecting active parties
        allow_null=True, required=False, # Party is optional for some voucher types (e.g., General, Contra)
        help_text=_("PK of the associated active Party (Customer/Supplier), if applicable.")
    )
    accounting_period = serializers.PrimaryKeyRelatedField(
        queryset=AccountingPeriod.objects.all(), # Allow selecting any period initially
        help_text=_("PK of the Accounting Period.")
    )
    # Generic Foreign Key handling (optional: allows linking to source docs like Invoice/Bill)
    content_type = serializers.PrimaryKeyRelatedField(
        queryset=ContentType.objects.all(), allow_null=True, required=False,
        help_text=_("Content type PK for the source document link (optional).")
        )
    object_id = serializers.IntegerField(allow_null=True, required=False, help_text=_("Object ID for the source document link (optional)."))

    class Meta:
        model = Voucher
        fields = [
            # Identifiers
            'id', 'voucher_number',

            # Core Header Data (Writeable on Create/Draft Update)
            'date', 'effective_date', 'reference', 'narration',
            'voucher_type',
            'party', 'accounting_period',

            # Status (Read-only via serializer, managed by workflow)
            'status', 'status_display',

            # Source Document Link (Optional)
            'content_type', 'object_id',

            # Nested Lines
            'lines',

            # Calculated/Display Fields (Read-Only)
            'total_debit', 'total_credit', 'is_balanced', 'is_editable',

            # Timestamps (Read-Only)
            'created_at', 'updated_at',
        ]
        # Define fields strictly managed by the system or workflow
        read_only_fields = [
            'id', 'voucher_number', 'status', 'status_display', 'total_debit',
            'total_credit', 'is_balanced', 'is_editable', 'created_at', 'updated_at'
        ]

    def __init__(self, *args, **kwargs):
        """Dynamically adjust read-only status based on instance state."""
        super().__init__(*args, **kwargs)
        instance = kwargs.get('instance')
        # Make most fields read-only if the voucher is not editable (POSTED/CANCELLED)
        # This provides quicker feedback in the API than waiting for model.save() validation.
        if instance and not instance.is_editable:
            # Define fields that become immutable once posted/cancelled
            immutable_fields = [
                'date', 'effective_date', 'reference', 'narration', 'voucher_type',
                'party', 'accounting_period', 'lines', 'content_type', 'object_id'
            ]
            for field_name in immutable_fields:
                if field_name in self.fields:
                    self.fields[field_name].read_only = True

    # --- Validation Methods ---

    def validate_accounting_period(self, period):
        """Validate accounting period selection (basic check)."""
        # Primary lock check happens in model/service layer, but can check here for early feedback
        # Allow selecting it, but maybe warn or prevent *creation* into a locked period?
        # This example allows selection, relies on model clean() for enforcement upon save.
        if period and period.locked:
            logger.warning(f"Selected accounting period '{str(period)}' is locked.")
            # Optionally raise error on create:
            # if self.instance is None:
            #     raise serializers.ValidationError(
            #         _("Cannot create voucher in locked accounting period '%(period)s'.") % {'period': str(period)},
            #         code='period_locked'
            #     )
        return period

    def validate_date(self, value):
        """Ensure date is provided."""
        if value is None:
            raise serializers.ValidationError(_("Date is required."))
        # Add future date restriction if needed:
        # from django.utils import timezone
        # if value > timezone.now().date():
        #    raise serializers.ValidationError(_("Voucher date cannot be in the future."))
        return value

    def validate(self, data):
        """
        Perform object-level validation:
        - Balance Check (Debits == Credits > 0)
        - Party Type vs Voucher Type Rules
        - Date within selected Period range
        - Immutability check (early feedback)
        - Voucher Type specific line content rules
        """
        instance = self.instance
        # Use initial_data for checks related to input payload, combine for full context
        # Combine instance data (if updating) with payload data for validation context
        # Exclude 'lines' from header data as it's handled separately
        header_data = {k: v for k, v in data.items() if k != 'lines'}
        full_data = {**getattr(instance, '__dict__', {}), **header_data} if instance else header_data

        # --- Immutability Check (Early Feedback) ---
        if instance and not instance.is_editable:
            changing_fields = {f for f in header_data if f not in ['status']} # Ignore status check here
            if changing_fields or 'lines' in self.initial_data: # Check if lines payload was sent too
                raise serializers.ValidationError(
                    _("Cannot update voucher: Status is '%(status)s'. Entry is locked.") % {'status': instance.get_status_display()},
                    code='voucher_locked'
                )

        # --- Line-Based Validations ---
        lines_data = self.initial_data.get('lines') # Get original lines payload for validation
        if lines_data is not None: # Only if lines are being sent
            if len(lines_data) < 2:
                raise serializers.ValidationError({"lines": _("A voucher must have at least two lines.")})
            # 1. Validate Balance
            self._validate_lines_balance(lines_data)
            # 2. Validate Voucher Type Specific Rules (Account Roles, etc.)
            self._validate_lines_voucher_type_rules(full_data, lines_data) # Pass combined header data
        elif not instance: # Creating new voucher requires lines
            raise serializers.ValidationError({"lines": _("Voucher lines are required during creation.")})

        # --- Date within Period Validation ---
        acc_period = full_data.get('accounting_period')
        voucher_date = full_data.get('date')
        if isinstance(acc_period, int): # If PK was passed, fetch the object for validation
            try:
                acc_period = AccountingPeriod.objects.get(pk=acc_period)
            except AccountingPeriod.DoesNotExist:
                acc_period = None # Let field validation handle invalid PK

        if acc_period and voucher_date:
            if not (acc_period.start_date <= voucher_date <= acc_period.end_date):
                raise serializers.ValidationError({
                    'date': _("Voucher date %(v_date)s is outside the selected period '%(p_name)s' range (%(p_start)s to %(p_end)s).") %
                    {'v_date': voucher_date, 'p_name': str(acc_period), 'p_start': acc_period.start_date, 'p_end': acc_period.end_date}
                })

        # --- Party Type vs Voucher Type Validation ---
        self._validate_party_vs_voucher_type(full_data) # Pass combined data

        # Manual number validation removed.

        return data # Return the validated header data (lines handled in create/update)

    def _validate_lines_balance(self, lines_data):
        """Check if provided lines balance and are non-zero."""
        total_debit = sum(Decimal(line.get('amount', 0) or 0) for line in lines_data if line.get('dr_cr') == DrCrType.DEBIT)
        total_credit = sum(Decimal(line.get('amount', 0) or 0) for line in lines_data if line.get('dr_cr') == DrCrType.CREDIT)

        if total_debit.quantize(Decimal("0.01")) != total_credit.quantize(Decimal("0.01")):
            raise serializers.ValidationError({"lines": _("Voucher lines do not balance. Debits: %(dr)s, Credits: %(cr)s") % {'dr': total_debit, 'cr': total_credit}}, code='unbalanced')
        if total_debit <= Decimal('0.00'):
            raise serializers.ValidationError({"lines": _("Voucher total amount must be greater than zero.")}, code='zero_amount')

    def _validate_lines_voucher_type_rules(self, voucher_data, lines_data):
        """Apply specific line validation rules based on VoucherType using account roles."""
        voucher_type = voucher_data.get('voucher_type')
        if not voucher_type or not lines_data: return

        relevant_types = [VoucherType.PAYMENT, VoucherType.RECEIPT, VoucherType.CONTRA, VoucherType.SALES]
        if voucher_type in relevant_types:
            account_pks = [line.get('account') for line in lines_data if line.get('account')] # Get PKs from payload
            if not account_pks: return
            # Fetch roles efficiently
            accounts_map = {acc.pk: acc.account_role for acc in Account.objects.filter(pk__in=account_pks).only('pk', 'account_role')}

            try:
                if voucher_type == VoucherType.PAYMENT: self._check_payment_rules(lines_data, accounts_map)
                elif voucher_type == VoucherType.RECEIPT: self._check_receipt_rules(lines_data, accounts_map)
                elif voucher_type == VoucherType.CONTRA: self._check_contra_rules(lines_data, accounts_map)
                elif voucher_type == VoucherType.SALES: self._check_sales_rules(lines_data, accounts_map)
            except KeyError as e:
                logger.error(f"Account role lookup failed for account PK {e} during validation.")
                raise serializers.ValidationError({"lines": _("Invalid account PK %(pk)s specified.") % {'pk': e}})

    def _validate_party_vs_voucher_type(self, voucher_data):
        """Validate Party Type against Voucher Type."""
        voucher_type = voucher_data.get('voucher_type')
        party_ref = voucher_data.get('party') # Could be PK or instance
        party_instance = None

        if isinstance(party_ref, Party):
            party_instance = party_ref
        elif isinstance(party_ref, int):
            try:
                party_instance = Party.objects.only('id', 'party_type').get(pk=party_ref)
            except Party.DoesNotExist:
                 # Let PrimaryKeyRelatedField handle invalid PK error usually
                return

        if voucher_type and party_instance:
            party_type = party_instance.party_type

            # Rule: Purchase/Payment -> Supplier
            if voucher_type in [VoucherType.PURCHASE, VoucherType.PAYMENT]:
                if party_type != PartyType.SUPPLIER:
                    raise serializers.ValidationError({'party': _("Purchase/Payment vouchers must use a 'Supplier' party type, not '%(type)s'.") % {'type': party_instance.get_party_type_display()}})

            # Rule: Sales/Receipt -> Customer
            elif voucher_type in [VoucherType.SALES, VoucherType.RECEIPT]:
                if party_type != PartyType.CUSTOMER:
                    raise serializers.ValidationError({'party': _("Sales/Receipt vouchers must use a 'Customer' party type, not '%(type)s'.") % {'type': party_instance.get_party_type_display()}})

        # Rule: Contra -> No Party
        if voucher_type == VoucherType.CONTRA and party_instance:
             raise serializers.ValidationError({'party': _("Contra vouchers should not have an associated party.")})


    # --- Helper rule checkers (using dynamically generated role sets) ---
    # These raise serializers.ValidationError on failure
    def _check_payment_rules(self, lines_data, accounts_map):
        if not any(accounts_map.get(line.get('account')) in CASH_BANK_ROLES for line in lines_data if line.get('dr_cr') == DrCrType.CREDIT and line.get('account')):
             raise serializers.ValidationError({"lines": _("Payment voucher must have a Credit line to a Cash or Bank account.")})

    def _check_receipt_rules(self, lines_data, accounts_map):
        if not any(accounts_map.get(line.get('account')) in CASH_BANK_ROLES for line in lines_data if line.get('dr_cr') == DrCrType.DEBIT and line.get('account')):
             raise serializers.ValidationError({"lines": _("Receipt voucher must have a Debit line to a Cash or Bank account.")})

    def _check_contra_rules(self, lines_data, accounts_map):
        for i, line in enumerate(lines_data):
             account_pk = line.get('account')
             if account_pk:
                 account_role = accounts_map.get(account_pk)
                 if account_role not in CASH_BANK_ROLES:
                      raise serializers.ValidationError({f"lines[{i}].account": _("Contra voucher lines must involve only Cash or Bank accounts (Role: %(role)s).") % {'role': account_role}})

    def _check_sales_rules(self, lines_data, accounts_map):
        allowed_debit_roles = ACCOUNTS_RECEIVABLE_ROLES.union(CASH_BANK_ROLES)
        has_allowed_debit = any(accounts_map.get(line.get('account')) in allowed_debit_roles for line in lines_data if line.get('dr_cr') == DrCrType.DEBIT and line.get('account'))
        has_sales_credit = any(accounts_map.get(line.get('account')) in SALES_REVENUE_ROLES for line in lines_data if line.get('dr_cr') == DrCrType.CREDIT and line.get('account'))
        if not has_allowed_debit:
             raise serializers.ValidationError({"lines": _("Sales voucher usually requires a Debit to Accounts Receivable, Cash, or Bank.")})
        if not has_sales_credit:
             raise serializers.ValidationError({"lines": _("Sales voucher usually requires a Credit to a Sales Revenue account.")})


    # --- Create and Update Logic ---

    @transaction.atomic
    def create(self, validated_data):
        """Create Voucher header and associated lines."""
        # Lines data needs to be accessed from the original request payload
        # DRF standard practice is to use self.initial_data
        lines_data = self.initial_data.get('lines', [])
        if not lines_data:
            # This case should ideally be caught by validate() requiring lines
            raise serializers.ValidationError({"lines": _("Cannot create voucher without lines.")})

        # Create header first (Model's save triggers numbering if status implies it)
        voucher = Voucher.objects.create(**validated_data)

        # Create lines, validating each one
        line_instances = []
        for line_data in lines_data:
            # Prepare data for nested serializer (it expects field names, not objects for relations on input)
            line_data_for_serializer = line_data.copy()
            account_pk = line_data_for_serializer.pop('account', None) # Get account PK if present
            if account_pk:
                 line_data_for_serializer['account'] = account_pk # Pass PK to serializer

            line_serializer = VoucherLineSerializer(data=line_data_for_serializer)
            if line_serializer.is_valid(raise_exception=True):
                # Need to manually add the voucher fk after validation before saving
                line_instance = line_serializer.save(voucher=voucher)
                line_instances.append(line_instance)
            # No else needed due to raise_exception=True

        # Refresh to get final state (potentially including generated voucher number)
        voucher.refresh_from_db()
        return voucher

    @transaction.atomic
    def update(self, instance, validated_data):
        """Update Voucher header and handle create/update/delete of lines."""
        # Access original lines payload via initial_data
        lines_data = self.initial_data.get('lines', None)

        # Update header fields first using super().update()
        # This calls instance.save(), enforcing immutability via model/serializer __init__ logic
        try:
            instance = super().update(instance, validated_data)
        except DjangoValidationError as e: # Catch errors from model .save()/.clean()
            raise serializers.ValidationError(e.message_dict if hasattr(e, 'message_dict') else str(e))

        # --- Handle Line Updates (Only if lines data was provided in the request) ---
        if lines_data is not None:
            existing_lines = {line.id: line for line in instance.lines.all()}
            # Map incoming lines by ID if they have one
            incoming_lines_map = {line.get('id'): line for line in lines_data if line.get('id')}

            # Update or Create Lines
            new_line_instances = []
            for line_data in lines_data:
                line_id = line_data.get('id')
                # Prepare data for nested serializer
                line_data_for_serializer = line_data.copy()
                account_pk = line_data_for_serializer.pop('account', None)
                if account_pk:
                     line_data_for_serializer['account'] = account_pk

                if line_id and line_id in existing_lines:
                    # Update existing line
                    line_instance = existing_lines[line_id]
                    line_serializer = VoucherLineSerializer(line_instance, data=line_data_for_serializer, partial=True)
                    if line_serializer.is_valid(raise_exception=True):
                        line_serializer.save() # Save the changes to the line
                elif not line_id:
                    # Create new line
                    line_serializer = VoucherLineSerializer(data=line_data_for_serializer)
                    if line_serializer.is_valid(raise_exception=True):
                         # Save new line, associating with the voucher instance
                         new_line_instance = line_serializer.save(voucher=instance)
                         new_line_instances.append(new_line_instance)

            # Delete lines that existed before but are not in the incoming update payload
            ids_to_delete = set(existing_lines.keys()) - set(incoming_lines_map.keys())
            if ids_to_delete:
                logger.info(f"Deleting VoucherLines {ids_to_delete} for Voucher {instance.pk}")
                VoucherLine.objects.filter(voucher=instance, id__in=ids_to_delete).delete()

        # Refresh instance to reflect all changes for the response
        instance.refresh_from_db()
        return instance